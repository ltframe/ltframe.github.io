<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Menthol document</title>
    <link href="static/stylesheets/document.css" rel="stylesheet" type="text/css" />

</head>
<body>
<div style="font-size: 12px" id="menu">
<H1>Menthol 1.0.0.2 手册</H1>
<p><a href="/static/doc/Mentho1002参考手册.pdf">Menthol 1.0.0.2  PDF </a></p>
<p>第一章：关于Menthol</p>
<p>&nbsp; &nbsp; &nbsp; 1.1.<a href="#1.1"><u>什么是</u><u>Menthol</u></a></p>
<p>&nbsp; &nbsp; &nbsp; 1.2.<a href="#1.2"><u>准备工作</u></a></p>
<p>&nbsp; &nbsp; &nbsp; 1.3.<a href="#1.3"><u>开始写第一个程序</u></a></p>
<p>&nbsp; &nbsp; &nbsp; 1.4.<a href="#1.4"><u>关键字</u></a></p>
<p>&nbsp; &nbsp; &nbsp; 1.5.<a href="#1.5"><u>程序注释</u></a></p>
<p>第二章：语言参考&nbsp; &nbsp; &nbsp; 
<p>&nbsp; &nbsp; &nbsp; 2.1数据类型</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.1.1 &nbsp;<a href="#2.1.1"><u>基础</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.1.2. <a href="#2.1.2"><u>布尔类型</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.1.3. <a href="#2.1.3"><u>数值类型</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.1.4. <a href="#2.1.4"><u>字符串类型</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.1.5. <a href="#2.1.5"><u>数组类型</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.1.6. <a href="#2.1.6"><u>字典类型</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.1.7. <a href="#2.1.7"><u>object</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.1.8. <a href="#2.1.8"><u>null类型</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.1.9. <a href="#2.1.9"><u>函数类型</u></a></p>
<p>&nbsp; &nbsp; &nbsp; 2.2 变量</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.2.1. <a href="#2.2.1"><u>变量基础</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.2.2. <a href="#2.2.2"><u>作用域</u></a></p>
<p>&nbsp; &nbsp; &nbsp; 2.3 表达式</p>
<p>&nbsp; &nbsp; &nbsp; 2.4 运算符</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.1.<a href="#2.4.1"><u>运算符基础</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.2.<a href="#2.4.2"><u>加(+)运算符</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.3.<a href="#2.4.3"><u>减(-)运算符</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.4.<a href="#2.4.4"><u>乘(*)运算符</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.5.<a href="#2.4.5"><u>除(/)运算符</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.6.<a href="#2.4.6"><u>三目(?:)运算符</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.7.<a href="#2.4.7"><u>按位&ldquo;或&rdquo;运算符 (|)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.8.<a href="#2.4.8"><u>按位&ldquo;与&rdquo;运算符 (&amp;)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.9.<a href="#2.4.9"><u>逻辑&ldquo;非&rdquo;运算符 (!)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.10.<a href="#2.4.10"><u>取余运算符 (%)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.11.<a href="#2.4.11"><u>按位&ldquo;异或&rdquo;运算符 (^)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.12.<a href="#2.4.12"><u>赋值运算符 (=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.13.<a href="#2.4.13"><u>小于运算符 (&lt;)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.14.<a href="#2.4.14">)" &gt;<u>大于运算符 (&gt;)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.15.<a href="#2.4.15">)" &gt;<u>比较运算符 (!=)(&lt;&gt;)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.16.<a href="#2.4.16"><u>逻辑&ldquo;或&rdquo;运算符 (||)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.17.<a href="#2.4.17"><u>逻辑&ldquo;与&rdquo;运算符 (&amp;&amp;)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.18.<a href="#2.4.18"><u>逻辑&ldquo;大于或等于&rdquo;运算符 (&gt;=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.19.<a href="#2.4.19"><u>逻辑&ldquo;小于或等于&rdquo;运算符 (&lt;=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.20.<a href="#2.4.20"><u>逻辑&ldquo;等于&rdquo;运算符 (==)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.21.<a href="#2.4.21"><u>加法赋值运算符 (+=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.22.<a href="#2.4.22"><u>减法赋值运算符 (-=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.23.<a href="#2.4.23"><u>除法赋值运算符 (/=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.24.<a href="#2.4.24"><u>乘法赋值运算符 (*=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.25.<a href="#2.4.25"><u>取余赋值运算符 (%=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.26.<a href="#2.4.26"><u>按位&ldquo;与&rdquo;赋值运算符 (&amp;=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.27.<a href="#2.4.27"><u>按位&ldquo;或&rdquo;赋值运算符 (|=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.28.<a href="#2.4.28"><u>按位&ldquo;异或&rdquo;赋值运算符 (^=)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.29.<a href="#2.4.29"><u>按位左移运算符 (&lt;&lt;)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.30.<a href="#2.4.30"><u>按位右移运算符 (&gt;&gt;)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.31.<a href="#2.4.31"><u>幂运算符 (**)</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.4.32.<a href="#2.4.32"><u>typeof</u></a></p>
<p>&nbsp; &nbsp; &nbsp; 2.5 &nbsp;流程控制</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.5.1.<a href="#2.5.1"><u>基本介绍</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.5.2.<a href="#2.5.2"><u>if else</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.5.3.<a href="#2.5.3"><u>while</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.5.4.<a href="#2.5.4"><u>for ...in</u></a>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.5.5.<a href="#2.5.5"><u>try...expcet</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.5.6.<a href="#2.5.6"><u>throw</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.5.7.<a href="#2.5.7"><u>break</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.5.8.<a href="#2.5.8"><u>continue</u></a></p>
<p>&nbsp; &nbsp; &nbsp; 2.6 &nbsp;函数</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.6.1.<a href="#2.6.1"><u>基本知识</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.6.2.<a href="#2.6.2"><u>函数定义和调用</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.6.3.<a href="#2.6.3"><u>函数参数</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.6.4.<a href="#2.6.4"><u>函数返回值</u></a></p>
<p>&nbsp; &nbsp; &nbsp; 2.7 包</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.7.1.<a href="#2.7.1"><u>包的基本概念</u></a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.7.2.<a href="#2.7.2"><u>导入包</u></a>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2.7.3.<a href="#2.7.3"><u>包的使用</u></a></p>
<p>第三章：API</p>
<p>&nbsp; &nbsp; &nbsp; 3.1.<a href="#3.1"><u>API列表</u></a></p>
<p>第四章：如何开发扩展库</p>
<p>&nbsp; &nbsp; &nbsp; 4.1.<a href="#4.1"><u>如何写一个扩展库</u></a></p>
</div>


<div id="allcontent">
<h1>第一章 关于Menthol</h1>
<h2 id="1.1">1.1. 什么是Menthol？</h2>
<p>Menthol 是一种解释型的、面向函数的编程语言。它采用C++开发而成，并且开放源码。配合简便的扩展方式，它可以满足你任何的开发需求</p> 
<p>不过，Menthol也有其局限性。你不能使用Menthol开发出独立的使用操作系统运行的程序，所有Menthol的程序都必须使用一个宿主进行解析后才可正常运行</p> 
<p>Menthol 是一种无类型的语言。无类型意味着不必显式定义变量的数据类型。实际上你也无法上明确地定义数据类型。因为所有的类型都是在运行时才会确定的。为了开发方便，Menthol还引入了包的概念，包就是一堆全局变量，函数的集合体，有点类似面向对象语言里的类的概念，但又不太相同。包可以是你自己开发的变量函数集合体，也可以是用C/C++开发出来的类库，不过在引用的时候它们没有差别</p> 


<h2 id="1.2">1.2.准备工作</h2>


   <p> Menthol是一个使用简单，易于学习的编程语言，如果你有其他编程语言，例如C,javascript,Python等编程语言的编写经验的话，本手册对你来说可能有点多余，你看看程序包或者源码包里的example中的实例就可以开始干了。其实我想说的是，Menthol就是如此简单的一个编程语言，下面我将详细说明</p> 

    <p>首先，你要获得menthol，访问www.ltplayer.com/menthol.html</p> 
    <img src="/static/mentholhtmlimg/mentholhtml4163.png"/>



<p>这个是menthol项目的页面，它部署于github上，如果你不想研究menthol的源码，直接点击getmenthol会进入编译版本的下载页面</p> 

 <img src="/static/mentholhtmlimg/mentholhtml4242.png"/>


  <p>点第一个就可以下载release版本就可以了。</p> 

  <p>这个是个压缩包，解压后你会看到大概像如下的结构</p> 


 <img src="/static/mentholhtmlimg/mentholhtml4301.png"/>




    <p>Compile.exe是编译程序，源码编写都要经过此程序编译后才能正常使用.Run.exe，为运行程序，编译后的源码使用此程序运行，便可以运行menthol程序。menthol.dll是动态链接库，是支持menthol运行的核心库，menthol.lib是静态库，如果你要开发menthol程序的话，需要使用这个静态库，menthol.h，头文件。</p> 

    <p>lib文件夹下，是menthol自带的一些基本的类库。example是一些实例，关于基本语法等，还包括一个使用zplay开发而成的简单音乐播放器</p> 

    <p>但是，如果你想研究或者自己编译menthol程序，就需要下载menthol源代码，同样进入menthol页面，点击sourcecode按钮，便会进入menthol在github上的项目仓库，不过前提需要你的电脑上安装过vs2013或者更高版本，因为menthol是在vs2013上开发而成，所以vs2013以下版本是否能正常编译，无法确定</p> 


     <img src="/static/mentholhtmlimg/mentholhtml4736.png"/>



<p>可以点击download zip下载源码，这个最简单，如果有你要clone 的话，需要git工具，这需要你有操作git工具的知识，本文档不讨论git文档的使用，不过git工具的使用并不复杂，如果使用GUI工具的话，使用会更加简便，读者只需简单学习便可以使用。</p> 


    <p>获得源码后，可以看到如下文件结构</p> 

          <img src="/static/mentholhtmlimg/mentholhtml4892.png"/>



<p>点击menthol.sln将会用打开。然后可以选择release或者debug编译,最后将在debug或者release文件夹中产生编译后的文件</p> 


<h2  id="1.3">1.3.开始写第一个程序</h2>


<p>一个完整的Menthol程序应该包括的是一个__mmain函数、导入的程序包、全局变量、和若干自定义函数。__mmain函数很重要，这是启动函数，在程序被调用时，系统会自动执行这个函数，作为整个程序调用的入口，所以，它是必须要有的，否则程序无法正常启动。一个最小的Menthol程序不要包含任何的程序包、全局变量，便可以正常启动。但这似乎并没有什么意义。下面的代码就是一个最小的menthol程序</p>
<p>_mmain:$a,$c</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>}</p>


<p>但是他什么都不执行，仅仅是程序编写上的正常。</p>


<p>你可以把它复制到记事本或其他编辑器内，将文件保存为main.me类型。me类型为menthol的可执行文件原文件名,取menthol单词的前两个字母。</p>

<p>现在打开控制台，并进入刚才文件所存储目录中，打开Compile.exe,将刚才你存的文件作为参数跟在后面，回车执行,如你还输入了-d的话,则会生成一些调试信息，包括发生错误时,原文件的行数，以及源文件的完整路径</p>

    <img src="/static/mentholhtmlimg/mentholhtml5427.png"/>

<p>好了，可以看到编译完成,你会发现在main.me下面多出来个main.mee。这个便是编译以后生成的文件，mee是menthol可执行文件的缩写(me execute)</p>

  <img src="/static/mentholhtmlimg/mentholhtml5517.png"/>

<p>&nbsp;&nbsp;&nbsp;&nbsp;然后我们就可以运行这个程序了，同样的操作方式，只不过要执行run.exe ,将刚才生成的main.mee 作为参数跟在后面执行即可。因为程序内什么都没有执行，所以没有任何输出。</p>


<p>因为menthol在程序启动的时候会自动载入两个库，MIo,和MSystem，所以，这两个库中的函数可以在任何文件内执行，而不用动态载入，现在把上述程序该一下。</p>
 <img src="/static/mentholhtmlimg/mentholhtml5721.png"/>

<p>然后重复上面的编译过程，然后运行</p>

 <img src="/static/mentholhtmlimg/mentholhtml5746.png"/>

<p>可以看看到了输出文字。MIo是控制输入输出与文件读写的库，我们会在后面讲到。</p>

<h2 id="1.4">1.4.关键字</h2>

<p>&ldquo;关键字&rdquo;是对menthol具有特殊含义的单词。标识符不能具有与 menthol关键字相同的拼写和大小写,同时你也不能重新定义关键字， 也不能将关键字用于定义函数名。Menthol目前拥有19个关键字，下面是所有关键字</p>


<p>if &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw &nbsp;&nbsp;&nbsp;&nbsp;continue &nbsp;&nbsp;&nbsp;return &nbsp;&nbsp;&nbsp;&nbsp;while &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import &nbsp;&nbsp;&nbsp;_mmain &nbsp;&nbsp;&nbsp;def &nbsp;&nbsp;&nbsp;var &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof</p>

<h2 id="1.5">1.5.程序注释</h2>

<p>&ldquo;注释&rdquo;就是你不舍得删除又嫌它碍眼，或者你可能又不知道在啥时候会继续使用的一段代码的临时废除符号，使用注释符号，可以把你代码中被注释的代码在编译时候忽略掉，但你还能看见它，但编译器不会处理它，它的存在不会对程序运行起任何作用</p>

<p>&ldquo;注释&rdquo;是一个以正斜杠/星号组合（/*）开头的字符序列，到分隔符 (*/) 结束的一段表示。 注释可以占用多行，但无法嵌套。如果你要注释单行也可以采用两个正斜杠//</p>

 <img src="/static/mentholhtmlimg/mentholhtml6353.png"/>



<h1>第二章：语言参考</h1>

<h2 id="2.1">2.1数据类型</h2>
<h3 id="2.1.1">2.1.1基础</h3>

<p>Menthol支持目前以下几种类型：</p>

<ol>
<li>数值</li>
<li>Null</li>
<li>字符串</li>
<li>数组</li>
<li>字典</li>
<li>Object</li>
<li>布尔类型</li>
<li>函数类型</li>
</ol>

 <img src="/static/mentholhtmlimg/mentholhtml6469.png"/>

<p>Menthol作为无类型语言，变量类型可以随时转换类型，而不需其它任何操作</p>

<h3 id="2.1.2">2.1.2 布尔类型</h3>

<p>布尔类型是数据类型中最简单的类型了，就两个值，true,false，它区分大小写</p>

<p>声明一个布尔类型如下</p>

 <img src="/static/mentholhtmlimg/mentholhtml6606.png"/>
<p>布尔类型的值通常用在流程判断里，例如while,if语句中</p>

 <img src="/static/mentholhtmlimg/mentholhtml6667.png"/>
<p>但是布尔值也是可以隐式转换的，比如:</p>
<ol>
<li>用在判断中的时候，0表示为false,非0表位为true</li>
<li>用在加法时候，false将转换为数值0,true将转换为数值1</li>
<li>用在字符串连接的时候,false将转换为字符串&rdquo;false&rdquo;,true将转换为字符串&rdquo;true&rdquo;</li>
</ol>


<h3 id="2.1.3">2.1.3 数值类型</h3>

<p>数值可以使用十进制，十六进制，八进制表示，前面可以加上可选的符号（- 或者 +）。 要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。</p>

 <img src="/static/mentholhtmlimg/mentholhtml6927.png"/>
<p>数值类型的表示范围为-2^1024 ~ +2^1024,如果超过这个范围，程序将会报错。</p>

<p>在表示布尔判断的时候.0将表示为false,非0将表示为true</p>
 <img src="/static/mentholhtmlimg/mentholhtml7037.png"/>

<h3 id="2.1.4">2.1.4 字符串类型</h3>
<p>一个字符串 <a href="mk:@MSITStore:E:\BaiduYunDownload\mydocuments\php_manual_zh.chm::/res/language.types.string.html">string</a>&nbsp;就是由一系列的字符组成，其中每个字符等同于一个字节</p>
<p>定义一个字符串的最简单的方法是用双引号（&ldquo;）把它包围起来。 如果&rdquo;&rdquo;中没有任何字符，则称之为空字符串，它代表&ldquo;&rdquo;中只有一个没有字符，从计算机本身的角度来讲空字符串中也有要给字符是\0，ascii为0</p>
 <img src="/static/mentholhtmlimg/mentholhtml7335.png"/>

<p>要表达一个单引号自身，需在它的前面加个反斜线（\）来转义。要表达一个反斜线自身，则用两个反斜线（\\）。其它任何方式的反斜线都会被当成反斜线本身：也就是说如果想使用其它转义序列例如 \r 或者 \n，并不代表任何特殊含义，就单纯是这两个字符本身。</p>
<p><strong><strong>转义符列表</strong></strong></p>
<table>
<tbody>
<tr>
<td width="83">
<p>转移符</p>
</td>
<td width="141">
<p>含义</p>
</td>
</tr>
<tr>
<td width="83">
<p>\n</p>
</td>
<td width="141">
<p>换行</p>
</td>
</tr>
<tr>
<td width="83">
<p>\r</p>
</td>
<td width="141">
<p>回车</p>
</td>
</tr>
<tr>
<td width="83">
<p>\b</p>
</td>
<td width="141">
<p>退格</p>
</td>
</tr>
<tr>
<td width="83">
<p>\&rdquo;</p>
</td>
<td width="141">
<p>双引号</p>
</td>
</tr>
</tbody>
</table>

<p>字符串的连接通过加号（+）来实现，可以将两个或多个字符串连接在一起成为一个新的字符串</p>
 <img src="/static/mentholhtmlimg/mentholhtml7577.png"/>


<p>事实上。字符串也是一个数组，关于数组的操作可以应用于字符串中，有关数组的定义及操作方式，下一节将会介绍</p>

<h3 id="2.1.5">2.1.5. 数组类型</h3>

<p>所谓数组，是有序的元素序列。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素</p>

<p>Menthol定义数组使用括号定义([]),在括号中，包含若干用逗号（，）分给的元素。如果括号中没有元素，则这个数组为0个元素的数组。数组元素可以是Menthol中的任何类型、表达式。</p>

 <img src="/static/mentholhtmlimg/mentholhtml7839.png"/>
<p>如果要获取数组元素或设置数组元素的新值，可以使用[]来实现，[]是填写数组的索引值，索引值也称为下标，从0开始，0表示数组的第一个元素</p>

 <img src="/static/mentholhtmlimg/mentholhtml7938.png"/>

<p>如果要设置也可以用[]方式来表示，如果设置一个大于当前数组索引的值，则这个索引以前的元素会被自动填充为null</p>

 <img src="/static/mentholhtmlimg/mentholhtml8025.png"/>

<p>在上一节讲道字符串也是数组的时候说过，数组的操作方式也适用于字符串</p>
 <img src="/static/mentholhtmlimg/mentholhtml8090.png"/>
<h3 id="2.1.6">2.1.6. 字典类型</h3>
<p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值&nbsp;key,value&nbsp;对用双冒号&nbsp;::&nbsp;分割，每个键值对之间用逗号&nbsp;,&nbsp;分割，整个字典包括在括号()中 , 在字典中，键是唯一的，但值可以重复，键必须是字符串类型，但值可以是任意类型</p>
<img src="/static/mentholhtmlimg/mentholhtml8259.png"/>

<p>值可以设置任何数据类型，但键必须是不可变的。</p>

<p>字典的取值和设置方式同样也是通过key,value&nbsp;用双冒号分割&rdquo;::&rdquo;</p>

<img src="/static/mentholhtmlimg/mentholhtml8351.png"/>
<p>字典的便利可以通过for in 方式</p>

<img src="/static/mentholhtmlimg/mentholhtml8401.png"/>
<p>如果要设置一个不存在的key，则会将新设置的key加入到字典中，如果取一个不存在的值则会返回null</p>
<img src="/static/mentholhtmlimg/mentholhtml8483.png"/>
<h3 id="2.1.7">2.1.7. object</h3>

<p>Object 通常用在和外部扩展库的交互上，例如C/C++返回了指针类型，则在menthol程序总表示为Object类型，但在menthol源码中，不会使用这种类型</p>



<h3 id="2.1.8">2.1.8. null类型</h3>
<p>null是一个特殊的数据类型,null 值表示一个变量没有值。其实际含义就是部署于任何类型</p>
<p>在下列情况下一个变量被认为是 NULL：</p>
<p>1.被赋值为 NULL。</p>
<p>2.未被赋值。</p>
<img src="/static/mentholhtmlimg/mentholhtml8719.png"/>


<h3 id="2.1.9">2.1.9. 函数类型</h3>

<p>函数类型不是说定义一个函数，而是说把函数看做一个变量类型，例如把函数当做另一个函数的参数传入，通常被称为回调函数</p>
<img src="/static/mentholhtmlimg/mentholhtml8822.png"/>

<p>函数类型类型可以是包函数，本包内函数，但需要在使用前就已经定义，否则编译将会报错</p>
<img src="/static/mentholhtmlimg/mentholhtml8894.png"/>
<p><strong><strong>2.2变量</strong></strong></p>
<h3 id="2.2.1">2.2.1.变量基础</h3>
<p>menthol中的变量用一个var关键字空格，变量名来表示一个变量。在menthol中变量分为全局变量和局部变量两种，全局变量为在一个包内可以发生作用的变量用@为前缀，局部变量为一个函数内或者一个作用域内发生作用的变量，用$符号后面跟变量名来表示。变量名是区分大小写的。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线</p>
<img src="/static/mentholhtmlimg/mentholhtml9118.png"/>

<p>变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量</p>
<img src="/static/mentholhtmlimg/mentholhtml9248.png"/>
<p>变量的声明，可以不要初始化，如果不初始化则变量被默认声明为null,全局变量和局部变量都一样</p>
<img src="/static/mentholhtmlimg/mentholhtml9325.png"/>

<p>变量的声明可以是一行一个，也可以在一个var 关键字后声明多个变量，并且遵循可以初始化也可以不初始化的原则</p>
<img src="/static/mentholhtmlimg/mentholhtml9410.png"/>


<p>一个重要原则，任何变量的使用(调用或给其赋值)，在使用前必须优先被声明，如果未声明时而使用或者在使用后再声明，则编译程序将会报错</p>
<img src="/static/mentholhtmlimg/mentholhtml9506.png"/>

<h3 id="2.2.2">2.2.2.作用域</h3>

<p>对于menthol来说作用域一般指一个包、运行程序，以及花括号&rdquo;{}&rdquo;，变量的范围即它定义的上下文背景（也就是它的生效范围）。</p>
<img src="/static/mentholhtmlimg/mentholhtml9614.png"/>
<p>对于全部变量，他的作用域在整个程序运行范围内，也就是说，在程序启动后，全部变量不论是不是在本包内，都是可见的，他的生存期是在整个程序启动到结束</p>
<p>对于函数参数，它的作用域就是本函数内，出了本函数，参数就失效了.</p>
<p>对于for in 中的临时变量生命，它只在for in 的循环体内</p>
<img src="/static/mentholhtmlimg/mentholhtml9782.png"/>


<h2  id="2.3">2.3表达式</h2>
<p>对大多数语言来说，程序就是一堆表达式的集合.在menthol中，任何的语句基本都叫做表达式，最简单的表达式就是语句的结束符&rdquo;;&rdquo;，这就是个表达式，没有任何意思。再比如随便一个数组，数字，字符串，声明、赋值语句等，都可以叫做表达式</p>
<img src="/static/mentholhtmlimg/mentholhtml9938.png"/>
<p>但是，一定要注意，任何一个表达式，它的结尾都要有结束符 &ldquo;;&rdquo;,否则会被编译器认为存在语法错误。表达式一行可以写多个，但需要在每个表达式后面写结束符</p>
<p>不过表达式本身是可以用&rdquo;,&rdquo;分割的，例如</p>
<p>$a = 1,2,3;</p>

<p>类似这种的也是合法的表达式，但是上边的表达式，只会返回1赋值给$a.所以对于声明变量,一下声明都是正确的</p>
<img src="/static/mentholhtmlimg/mentholhtml10131.png"/>
<h2  id="2.4">2.4运算符</h2>
<h3  id="2.4.1">2.4.1运算符基础</h3>

<p>运算符是可以通过给出的一或多个值（用编程行话来说，表达式）来产生另一个值（因而整个结构成为一个表达式）的东西。</p>
<p>运算符可按照其能接受几个值来分组。一元运算符只能接受一个值，例如 !（<a href="mk:@MSITStore:E:\BaiduYunDownload\mydocuments\php_manual_zh.chm::/res/language.operators.logical.html">逻辑取反运算符</a>）二元运算符可接受两个值，例如熟悉的<a href="mk:@MSITStore:E:\BaiduYunDownload\mydocuments\php_manual_zh.chm::/res/language.operators.arithmetic.html">算术运算符</a>&nbsp;+（加）和 -（减），大多数 PHP 运算符都是这种。最后是唯一的<a href="#language.operators.comparison.ternary">三元运算符</a>&nbsp;? :，可接受三个值；通常就简单称之为&ldquo;三元运算符&rdquo;（尽管称之为条件运算符可能更合适）。</p>


<p>Menthol支持目前以下运算符：</p>

<p>- * / () ; , | &amp; &nbsp;? [] ! % ^ : :: .. = &lt; &gt; != &lt;&gt; || &amp;&amp; &nbsp;&gt;= &lt;= == += -= /= *= %= &amp;= |= ^= &lt;&lt; &gt;&gt; **</p>
<p>typeof</p>



<h3  id="2.4.2">2.4.2.加法运算符</h3>

<p>将数字表达式的值加到另一数字表达式上，或连接两个字符串,数组等</p>

<p>result = expression1 + expression2</p>

<img src="/static/mentholhtmlimg/mentholhtml11012.png"/>

<p>expression1,expression2为表达式。</p>

<p>1.expression1,expression2同为数字时，相加</p>
<p>2.expression1,expression2同为bool时，先转换bool值为数字，true转换为1，false转换为0，然后相加</p>
<p>3.expression1,expression2同为string时，连接</p>
<p>4.expression1,expression2有一个为array时，组合为新的array</p>
<p>5.expression1,expression2有一个为string，另一个数字转字符串，bool转true,false,null转空</p>
<p>6.expression1,expression2 有一个为bool时,先转换bool值为数字，true转换为1，false转换为0，然后相加</p>
<p>7.expression1,expression2 有一个为null时,另一个如果是字符，null转换为空字符串，如果为数字时，true转换为1，false转换为0</p>



<h3  id="2.4.3">2.4.3减法运算符</h3>
<p>从一个表达式的值中减去另一个表达式的值，只有一个表达式时取其相反数。</p>
<p>result = expression1 -&nbsp;expression2</p>

<p>result = -expression1</p>
<img src="/static/mentholhtmlimg/mentholhtml11594.png"/>


<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0</p>

<p>除以上类型外，其他类型进行详见操作，则会报错</p>



<h3  id="2.4.4">2.4.4.乘(*)运算符</h3>

<p>两个表达式的值相乘。</p>

<p>result = expression1 * expression2</p>
<img src="/static/mentholhtmlimg/mentholhtml11773.png"/>


<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0</p>

<p>除以上类型外，其他类型进行详见操作，则会报错</p>



<h3  id="2.4.5">2.4.5.除法(/)运算符</h3>

<p>两个表达式的值相除。</p>

<p>result = expression1 / expression2</p>
<img src="/static/mentholhtmlimg/mentholhtml11953.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0</p>

<p>除以上类型外，其他类型进行详见操作，则会报错</p>



<h3  id="2.4.6">2.4.6.三目(?:)运算符</h3>
<p>根据条件执行两个语句中的其中一个。</p>
<p>test ? expression1 : expression2</p>
<p>test：bool表达式语句expression1,expression2为表达式.</p>
<p>当test为true则执行expression1,否则执行expression2</p>
<img src="/static/mentholhtmlimg/mentholhtml12221.png"/>

<h3  id="2.4.7">2.4.7.按位&ldquo;或&rdquo;运算符 (|)</h3>
<p>对两个表达式执行按位&ldquo;或&rdquo;</p>
<p>result = expression1 | expression2</p>
<p>expression1,expression2为表达式</p>
<p>运算符查看两个表达式的二进制表示法的值，并执行按位&ldquo;或&rdquo;操作。该操作的结果如下所示：</p>
<p>0101&nbsp;&nbsp;&nbsp;(expression1)</p>
<p>1100&nbsp;&nbsp;&nbsp;(expression2)</p>
<p>----</p>
<p>1101&nbsp;&nbsp;&nbsp;(结果)</p>
<p>任何时候，只要任一表达式的一位为 1，则结果的该位为 1。否则，结果的该位为 0。&nbsp;</p>


<h3  id="2.4.8">2.4.8.按位&ldquo;与&rdquo;运算符 (&amp;)</h3>

<p>对两个表达式执行按位&ldquo;与&rdquo;</p>
<p>result = expression1 &amp; expression2</p>
<p>expression1,expression2为表达式</p>
<p>运算符查看两个表达式的二进制表示法的值，并执行按位&ldquo;与&rdquo;操作。该操作的结果如下所示：</p>
<p>0101&nbsp;&nbsp;&nbsp;(expression1)</p>
<p>1100&nbsp;&nbsp;&nbsp;(expression2)</p>
<p>----</p>
<p>0100&nbsp;&nbsp;&nbsp;(结果)</p>
<p>任何时候，只要任一表达式的一位为 1，则结果的该位为 1。否则，结果的该位为 0。</p>


<h3  id="2.4.9">2.4.9.逻辑&ldquo;非&rdquo;运算符 (!)</h3>
<p>对一个表达式执行逻辑非。</p>
<p>result = !expression</p>
<p>Expression 任何<a href="#defexpressionjs">表达式</a>。</p>
<img src="/static/mentholhtmlimg/mentholhtml12948.png"/>
<p>Expression为null则转换为false,如果是数字，则0为false,非0为true,其他类型则true</p>



<h3  id="2.4.10">2.4.10.取余运算符 (%)</h3>
<p>一个表达式的值除以另一个表达式的值，返回余数。</p>
<p>result = number1 % number2</p>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0</p>

<p>除以上类型外，其他类型进行详见操作，则会报错</p>
<img src="/static/mentholhtmlimg/mentholhtml13188.png"/>
<p>取余（或余数）运算符用 number1 除以 number2 ,会将两个操作数做取整操作后，再取余数，然后只返回余数作为 result。</p>




<h3  id="2.4.11">2.4.11.按位&ldquo;异或&rdquo;运算符 (^)</h3>

<p>对两个表达式执行按位&ldquo;异或&rdquo;</p>
<p>result = expression1 ^ expression2</p>
<p>expression1,expression2为表达式</p>
<p>运算符查看两个表达式的二进制表示法的值，并执行按位&ldquo;异或&rdquo;操作。该操作的结果如下所示：</p>
<p>0101&nbsp;&nbsp;&nbsp;(expression1)</p>
<p>1100&nbsp;&nbsp;&nbsp;(expression2)</p>
<p>----</p>
<p>1001&nbsp;&nbsp;&nbsp;(结果)</p>
<p>任何时候，只要任一表达式的一位为 1，则结果的该位为 1。否则，结果的该位为 0。</p>



<h3  id="2.4.12">2.4.12.赋值运算符 (=)</h3>

<p>给变量赋值</p>
<p>result = expression</p>
<p>expression任何<a href="#defnumericexpressionjs">表达式</a>。</p>
<p>= 运算符和其他运算符一样，除了把值赋给变量外，使用它的表达式还有一个值。这就意味着可以象下面这样把赋值操作连起来写：</p>
<p>j =&nbsp;k =&nbsp;l =&nbsp;0;</p>
<p>执行完该例子语句后，j、k、和 l 的值都等于零。 但上面的写法，仅限于赋值，初始化不可以</p>


<h3  id="2.4.13">2.4.13.小于运算符 (&lt;)</h3>
<p>两个表达式的小于比较。</p>

<p>result = expression1 &lt;&nbsp;expression2</p>
<img src="/static/mentholhtmlimg/mentholhtml13930.png"/>


<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.两个字符串比较，遵循C的strcmp原则</p>

<p>除以上类型外，其他类型进行详见操作，则会报错</p>

<h3  id="2.4.14">2.4.14.大于运算符 (>)</h3>
<p>两个表达式的大于比较。</p>

<p>result = expression1 >expression2</p>

<img src="/static/mentholhtmlimg/mentholhtml14131.png"/>

<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.两个字符串比较，遵循C的strcmp原则</p>

<p>除以上类型外，其他类型进行详见操作，则会报错</p>



<h3  id="2.4.15">2.4.15.比较运算符 (!=)</h3>

<p>两个表达式的大于比较。</p>

<p>result = expression1 &lt;&gt;(!=) expression2</p>

<img src="/static/mentholhtmlimg/mentholhtml14343.png"/>

<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.两个字符串比较，按照逐字符比较</p>

<p>除以上类型外，其他类型进行详见操作，则会报错</p>




<h3  id="2.4.16">2.4.16.逻辑或运算符 (||)</h3>

<p>对两个表达式执行逻辑或。</p>

<p>result = expression1 || expression2</p>

<p>expression1,expression2为表达式。null时,转换为false,数字0转换为false,非0为true,其他类型为true</p>


<table>
<tbody>
<tr>
<td width="82">
<p>True</p>
</td>
<td width="99">
<p>True</p>
</td>
<td width="335">
<p>True</p>
</td>
</tr>
<tr>
<td width="82">
<p>True</p>
</td>
<td width="99">
<p>False</p>
</td>
<td width="335">
<p>True</p>
</td>
</tr>
<tr>
<td width="82">
<p>False</p>
</td>
<td width="99">
<p>True</p>
</td>
<td width="335">
<p>True</p>
</td>
</tr>
<tr>
<td width="82">
<p>False</p>
</td>
<td width="99">
<p>False</p>
</td>
<td width="335">
<p>False</p>
</td>
</tr>
</tbody>
</table>


<h3  id="2.4.17">2.4.17.逻辑&ldquo;与&rdquo;运算符 (&amp;&amp;)</h3>

<p>对两个表达式执行逻辑&ldquo;与&rdquo;。</p>
<img src="/static/mentholhtmlimg/mentholhtml14767.png"/>
<p>result = expression1 &amp;&amp; expression2</p>
<p>expression1,expression2为表达式。null时,转换为false,数字0转换为false,非0为true,其他类型为true</p>

<p>当且仅当两个表达式的值都等于 True 时， result 才是 True。如果任一表达式的值等于 False， 则 result 为 False。</p>


<h3  id="2.4.18">2.4.18.逻辑大于或等于运算符 (&gt;=)</h3>

<p>result = expression1 &gt;= expression2</p>
<img src="/static/mentholhtmlimg/mentholhtml15008.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.两个字符串比较，按照逐字符比较</p>



<h3  id="2.4.19">2.4.19.逻辑&ldquo;小于或等于&rdquo;运算符 (&lt;=)</h3>

<p>result = expression1 &lt;= expression2</p>
<img src="/static/mentholhtmlimg/mentholhtml15174.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.两个字符串比较，按照逐字符比较</p>

<h3  id="2.4.20">2.4.20.逻辑&ldquo;等于&rdquo;运算符 (==)</h3>

<p>result = expression1 == expression2</p>
<img src="/static/mentholhtmlimg/mentholhtml15336.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.两个字符串比较，按照逐字符比较</p>

<h3 id="2.4.21">2.4.21.加法赋值运算符 (+=)</h3>

<p>将变量值与表达式值相加，并将和赋给该变量。</p>

<p>result += expression</p>
<img src="/static/mentholhtmlimg/mentholhtml15505.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.两个字符串,则进行连接操作</p>

<p>使用本运算符与这样指定完全相同：</p>

<p>result = result + expression</p>

<h3 id="2.4.22">2.4.22.减法赋值运算符 (-=)</h3>

<p>将变量值与表达式值相减，并将和赋给该变量。</p>

<p>result -= expression</p>
  <img src="/static/mentholhtmlimg/mentholhtml15721.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.使用本运算符与这样指定完全相同：</p>
<p>result = result - expression</p>


<h3 id="2.4.23 id="2.4.22"">2.4.23.除法赋值运算符 (/=)</h3>
<p>将变量值与表达式值相除，并将和赋给该变量。</p>
<p>result /= expression</p>
  <img src="/static/mentholhtmlimg/mentholhtml15921.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.使用本运算符与这样指定完全相同：</p>
<p>result = result / expression</p>

<h3 id="2.4.24">2.4.24.乘法赋值运算符 (*=)</h3>

<p>将变量值与表达式值相乘，并将和赋给该变量。</p>
<p>result *= expression</p>
  <img src="/static/mentholhtmlimg/mentholhtml16121.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.</p>
<p>使用本运算符与这样指定完全相同：</p>
<p>result = result * expression</p>



<h3 id="2.4.25">2.4.25.取余赋值运算符 (%=)</h3>
<p>result %<strong><strong>=</strong></strong>&nbsp;expression</p>
  <img src="/static/mentholhtmlimg/mentholhtml16298.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.</p>
<p>使用本运算符与这样指定完全相同：</p>
<p>result = result % expression</p>

<h3 id="2.4.26">2.4.26.按位&ldquo;与&rdquo;赋值运算符 (&amp;=)</h3>
<p>result &amp;= expression</p>
  <img src="/static/mentholhtmlimg/mentholhtml16480.png"/>

<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.</p>
<p>使用本运算符与这样指定完全相同：</p>
<p>result = result &amp; expression</p>


<h3 id="2.4.27">2.4.27.按位&ldquo;或&rdquo;赋值运算符 (|=)</h3>
<p>result |= expression</p>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.</p>
  <img src="/static/mentholhtmlimg/mentholhtml16721.png"/>

<p>使用本运算符与这样指定完全相同：</p>
<p>result = result | expression</p>


<h3 id="2.4.28">2.4.28.按位&ldquo;异或&rdquo;赋值运算符 (^=)</h3>
<p>result ^= expression</p>
  <img src="/static/mentholhtmlimg/mentholhtml16843.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.其他类型则转换为0</p>
<p>使用本运算符与这样指定完全相同：</p>
<p>result = result ^ expression</p>



<h3 id="2.4.29">2.4.29.按位左移运算符 (&lt;&lt;)</h3>
<p>result = expression1 &gt;&gt; expression2</p>
  <img src="/static/mentholhtmlimg/mentholhtml17043.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.其他类型则转换为0</p>
<p>运算符把 expression1 的所有位向右移 expression2 指定的位数。expression1 的符号位被用来填充右移后左边空出来的位。向右移出的位被丢弃</p>


<h3 id="2.4.30">2.4.30.按位右移运算符 (&gt;&gt;)</h3>
<p>result = expression1 &gt;&gt; expression2</p>
  <img src="/static/mentholhtmlimg/mentholhtml17281.png"/>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.其他类型则转换为0</p>
<p>&lt;&lt; 运算符把 expression1 的所有位向左移 expression2 指定的位数。</p>



<h3 id="2.4.31">2.4.31.幂运算符 (**)</h3>
<p>result = expression1 ** expression2</p>
<p>expression1,expression2为表达式。null时,转换为0，true转换为1，false转换为0.</p>
  <img src="/static/mentholhtmlimg/mentholhtml17478.png"/>
<p>除以上类型外，其他类型进行详见操作，则会报错</p>



<h3 id="2.4.32">2.4.32.typeof</h3>
<p>result = typeof(expression)</p>
<p>返回expression的类型</p>

<h2>2.5 流程控制<h2>
<h3  id="2.5.1">2.5.1.基础介绍</h3>

<p>menthol中的语句一般是按照写的顺序来运行的。这种运行称为顺序运行，是程序流的默认方向。</p>

<p>与顺序运行不同，另一种运行将程序流转换到脚本的另外的部分。也就是，不按顺序运行下一条语句，而是运行另外的语句。</p>

<p>要使脚本可用，该控制的转换必须以逻辑方式执行。程序控制的转换是基于一个&ldquo;决定&rdquo;，这个&ldquo;决定&rdquo;结果是真或假（返回&nbsp; Boolean 型 true 或 false）。 创建一个表达式，然后测试其是否为真。主要有两种程序结构实现本功能。</p>

<p>Menthol使用三种流程控制方式</p>

<p>If ,if else ,while,for &nbsp;in</p>



<h3  id="2.5.2">2.5.2. if else</h3>
<p>根据一个表达式的值，有条件地执行一组语句。</p>
<p>if (condition){<br />&nbsp;&nbsp;&nbsp;statement1</p>
<p>}<br />[else{<br />&nbsp;&nbsp;&nbsp;statement2}]</p>

<p>condition必选项。一个 <a href="#defbooleanjs">Boolean 表达式</a></p>
<p>statement1可选项。condition 是 true 时要执行的语句。可以是<a href="#defcompoundstatement">复合语句</a>。statement2可选项。condition 是 false 时要被执行的语句。可以是复合语句。</p>
  <img src="/static/mentholhtmlimg/mentholhtml18434.png"/>
<p>If else 流程的else部分是可选的，可以不写，只写if 也是可以的</p>
  <img src="/static/mentholhtmlimg/mentholhtml18503.png"/>

<h3  id="2.5.3">2.5.3. while</h3>
<p>执行一个语句，直到指定的条件为 false。</p>
<p>while (expression){<br />&nbsp;&nbsp;&nbsp;statements</p>
<p>}</p>
<p>expression必选项。<a href="#defbooleanjs">Boolean 表达式</a>，在循环的每次迭代前被检查。 如果 expression 是 true，则执行循环。如果 expression 是 false，则结束循环。</p>
<p>statements可选项。expression 是 true 时要执行的一个或多个语句。</p>
  <img src="/static/mentholhtmlimg/mentholhtml18882.png"/>
<p>表达式的值在每次开始循环时检查，所以即使这个值在循环语句中改变了，语句也不会停止执行，直到本次循环结束。有时候如果 while 表达式的值一开始就是 FALSE，则循环语句一次都不会执行。</p>

<h3  id="2.5.4">2.5.4.for in</h3>
<p>对应于一个对象的每个，或一个数组的每个元素，执行一个或多个语句。</p>
<p>for (var variable,variable.... in [dict | array]){</p>
<p>}&nbsp;</p>
<p>variable必选项。一个<a href="#defvariablejs">变量</a>，它可以是 object 的任一属性或 array 的任一元素。&nbsp;</p>
<p>dict, array要在其上遍历的字典或数组。</p>
<p>statement可选项。相对于 object 的每个属性或 array 的每个元素，都要被执行的一个或多个语句。</p>
  <img src="/static/mentholhtmlimg/mentholhtml19375.png"/>
<p>在循环的每次迭代前，variable 被赋予 object 的下一个属性或 array 的下一个元素。然后可以在循环内的任一语句中使用它，就好像正在使用 object 的该属性或 array 的该元素一样。</p>
<p>如果结合是dict则variable至少需要两个，一个是key,一个是值</p>

<h3  id="2.5.5">2.5.5. try except</h3>
错误处理
<p>try&nbsp;{<br />&nbsp;&nbsp;&nbsp;statements1&nbsp;</p>
<p>}except:$arg1...{</p>
<p>statements2</p>
<p>}</p>
<p>statements可选.在执行statements1&nbsp;内容时，如果有throw抛出，则跳转至statements2,$arg1...为抛出错误时的参数可有多个</p>
  <img src="/static/mentholhtmlimg/mentholhtml19705.png"/>

<h3  id="2.5.6">2.5.6 throw </h3>
抛出错误
<p>Thorw $arg,$arg....</p>
  <img src="/static/mentholhtmlimg/mentholhtml19773.png"/>
<h3  id="2.5.7">2.5.7 break</h3>
<p>跳出一个循环，用在for in 和while中&nbsp;</p>
<p>Break是无条件的，碰到break就会跳出循环</p>
  <img src="/static/mentholhtmlimg/mentholhtml19865.png"/>
<h3  id="2.5.8">2.5.8 continue</h3>
<p>继续一个循环，用在for in 和while中&nbsp;</p>
<p>continue是无条件的，碰到continue就会跳会循环开始位置</p>
  <img src="/static/mentholhtmlimg/mentholhtml19970.png"/>

<p>2.6 函数</p>
<h3  id="2.6.1">2.6.1.基本知识</h3>
<p>函数执行操作，也可以返回值。某些时候是计算或比较的结果。函数又被称为&ldquo;全局方法&rdquo;。</p>
<p>一个函数中包含有几个操作。这样可使得代码更合理化。可以写一组语句并给其命名，然后通过调用它并传递其需要的信息来运行整组语句。</p>
<p>给函数传递信息可以把信息放在函数名称后面的圆括号中。传递给函数的信息称作参数。某些函数根本不带任何参数，而其他函数带一个或者多个参数。在某些函数中，参数的个数取决于如何使用该函数。</p>


<h3  id="2.6.2">2.6.2.函数定义和调用</h3>

<p>函数采用关键字def 函数名：参数的形式定义,参数名不是必须要的。函数名是区分大小写的，并且函数名只能使用下划线，字符，数字构成，并且函数名的第一个字符不能是数字.函数可以有返回值，也可以没有返回值</p>
  <img src="/static/mentholhtmlimg/mentholhtml20330.png"/>
<p>函数必须在调用之前被定义，否则编译程序将无法使用。 所有的函数都是基于包的概念存在的，他们全都在一个包内。</p>
<p>在同一包内，调用函数不需要加包名，只需要函数名（参数列表）就可以，但是代用外部包函数则需要报名.函数名（参数列表）.在本手册中多次使用的MIo.Out就是MIo包中的out函数</p>
  <img src="/static/mentholhtmlimg/mentholhtml20502.png"/>

<h3  id="2.6.3">2.6.3.函数参数</h3>
<p>通过参数列表可以传递信息到函数，即以逗号作为分隔符的表达式列表。参数是从左向右求值的，并且在menthol中参数值传递</p>
<p>1.函数的参数可能有多个，但在调用时候出入的参数比函数定义的参数要少，则默认传入NULL</p>
  <img src="/static/mentholhtmlimg/mentholhtml20648.png"/>
<p>2.函数参数如果少于传入的参数，则多余的将被忽略</p>
<p>3.函数的参数列表使用C++风格的默认参数，不过默认参数都是在最后，即有个默认参数后，后面要么是没有参数，要么剩下的都是默认参数</p>
  <img src="/static/mentholhtmlimg/mentholhtml20767.png"/>
<h3  id="2.6.4">2.6.4.函数返回值</h3>
<p>值通过使用可选的返回语句返回。可以返回包括数组和对象的任意类型。返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行</p>
  <img src="/static/mentholhtmlimg/mentholhtml20874.png"/>
<p>如果省略了 <a href="mk:@MSITStore:E:\BaiduYunDownload\mydocuments\php_manual_zh.chm::/res/function.return.html">return</a>，则返回值为 NULL。</p>

<h2>2.7包</h2>
<h3  id="2.7.1">2.7.1包的基本概念</h3>

<p>在menthol中，包分为两个类型，一个类型是用menthol写的包，另一个是用C/C++写的扩展包</p>

<p>menthol包的概念了类似于C++中类的概念，但二者又不是完全相同，在menthol包中，可以被访问的只有全局变量和函数两种类型，这两种类型好像C++中的public修饰一样。但menthol没有私有的概念。也没有继承的概念，可以这么说，就是个函数和全局变量的集合体。其他的包可以在引入这个包后调用这个这个包的全局变量和函数</p>

<p>Menthol包的扩展名是.mep,不过一个包从代码上来说和.me文件写法完全一样。包被编译好后，生成的文件扩展名为.med</p>

<p>扩展包就是编译后的C/C++类库，对于它来说，用户只能调用他的函数，它也没有全局变量的概念</p>



<h3  id="2.7.2">2.7.2.导入包 </h3>
<p>无论是menthol写的包还是C/C++写的扩展包，包名就是文件名，例如有个包叫做a.med则在程序使用他的时候使用</p>

<p>Improt &ldquo;a&rdquo;;</p>

<p>就可以导入这个包了，导入后，就可以在程序中使用这个包中的函数和全局变量了扩展包也一样.你不需要包名和文件名的大小写一定要保持一致，也可以是improt “A”,因为文件名并不区分大小写，但要主意的是，如果improt 以后的包名是“a”,则使用包的时候只能是a，如果import时候使用的是”A”则使用包的时候只能是A</p>

<h3  id="2.7.3">2.7.3.包的使用</h3>
<p>在导入包以后，如果要调用包内的全局变量则只需要包名.@变量名就可以，调用包内函数要包名.函数名（参数列表）即可</p>

<h1>第三章&nbsp;API列表<h1>

<h2   id="3.1">3.1.API列表</h2>


<p>所有的API都在menthol.h中可以看到</p>


<p>1.enum ValueType:表示所有menthol所使用的数据类型，有些你可能永远不会使用到，但你可以了解</p>
<p>M_NUMBER,M_LONG,M_DOUBLE,M_STRING,M_SSTRING,M_FUN,M_PFUN,M_BPMARK,M_BOOL,</p>
<p>M_ARRAY,M_DICT,M_NULL,M_TRYMARK,M_FORMARK,M_PACKAGE,M_HASH,M_UNKONWN,M_POINTER</p>

<p>2.struct StackState</p>
<p>{</p>

<p>union{</p>
<p>double d;//数值</p>
<p>int i;</p>
<p>hashValue hash;//hash值</p>
<p>pDict pdict;//字典值</p>
<p>pArray parray;//数组值</p>
<p>pString str;//字符串</p>
<p>StackMark m;</p>
<p>bool b;//布尔值</p>
<p>PackageState* ps;</p>
<p>};</p>
<p>pInst p;//表示一个object或者一个指针</p>
<p>char* name;</p>
<p>hashValue namehash;//变量或者函数名的hash值</p>
<p>ValueType v; //数据类型</p>
<p>};</p>
<p>3.typedef int (*PrintErrorFunc)(char* str,char* cf,int line);</p>
<p>错误调用的函数指针，str 参数为错误信息，cf为发生错误的文件，line 为错误的行数</p>

<p>4.typedef StackState (*funcallback)();</p>
<p>扩展函数函数的函数指针</p>

<p>5.MentholPackMethod void SetPrintCompileErrorFunc(PrintErrorFunc _pef);</p>
<p>指示编译时如果发生错，将调用哪个函数显示错误信息,_per为函数指针</p>

<p>6.MentholPackMethod void SetPrintRunTimeErrorFunc(PrintErrorFunc _pef);</p>
<p>指示运行时如果发生错，将调用哪个函数显示错误信息,_per为函数指针</p>

<p>7.MentholPackMethod int Compile2(char* cfile,bool isdebug);</p>

<p>8.MentholPackMethod int Run(char* files,char* arg1,char* arg2);</p>
<p>执行可执行文件,files为可执行文件.mee的完整文件名，arg1,为__mmain的第一个参数,arg2,为__mmain的第二个参数</p>

<p>9.MentholPackMethod void RegisterPackAgeFunciton(char* name,funcallback fun,int pcount);</p>
<p>向系统注册需要扩展的函数名，name为函数名，funcallback为函数指针，pcount为参数个数</p>

<p>10.MentholPackMethod StackState GetParam(int index);</p>
<p>获取函数参数，index为参数的索引位置，从1开始</p>

<p>11.MentholPackMethod StackState Array_CreateArray();</p>
<p>创建一个数组</p>

<p>12.MentholPackMethod StackState Array_Get(pArray sk1,int index);</p>
<p>获取数组元素，sk1为数组,index为数组位置索引，从0开始</p>


<p>13.MentholPackMethod void Array_Set(pArray sk1,StackState sk2,int index);<br />设置数组元素，sk1为数组,index为数组位置索引，从0开始，sk2为要这只的新值</p>

<p>14.MentholPackMethod int Array_Length(pArray p);</p>
<p>获取数组元素个数，p为数组</p>

<p>15.MentholPackMethod void Array_Push(pArray sk1,StackState sk2);</p>
<p>增加数组元素，sk1为数组,sk2为要增加的元素</p>

<p>16.MentholPackMethod pString Array_Join(pArray a1,char* link);</p>
<p>用link 将数组a1，连接在一起返回字符串</p>

<p>17.MentholPackMethod pArray Array_Reverse(pArray a1);</p>
<p>反转数组，返回新的数组</p>

<p>18.MentholPackMethod StackState Dict_CreateDict();</p>
<p>创建一个字典</p>

<p>19.MentholPackMethod void Dict_Push(char* key,pDict sk1,StackState sk2);</p>
<p>增加字典元素，key 为键，sk1为字典，sk2为值</p>

<p>20.MentholPackMethod int Dict_Length(pDict p);</p>
<p>获取字典键值对个数，p为字典</p>

<p>21.MentholPackMethod StackState Dict_Get(pDict sk1,hashValue key);</p>
<p>获取字典值对个数，sk1为字典，key为key的hash值</p>

<p>22.MentholPackMethod void Dict_Set(char* key,pDict sk1,StackState sk2);</p>
<p>设置字典值对个数，sk1为字典,key为键，sk2为新值</p>

<p>23.MentholPackMethod pString Dict_Key(pDict pdict,hashValue sk2);</p>
<p>获取字典值对个数，sk1为字典，key为key的hash值</p>

<p>24.MentholPackMethod StackState String_CreateString(char* str);</p>
<p>创建字符串</p>

<p>25.MentholPackMethod void CreateFunctionCall(int pc);</p>
<p>创建回调函数的运行环境,pc为压入函数的参数个数</p>

<p>26.MentholPackMethod void PushNumber(double d);</p>
<p>向栈内压入一个数值</p>

<p>27.MentholPackMethod void PushString(pString str);</p>
<p>向栈内压入一个字符串</p>

<p>28.MentholPackMethod void PushArray(pArray arr);</p>
<p>向栈内压入一个数组</p>

<p>29.MentholPackMethod void PushDict(pDict arr);</p>
<p>向栈内压入一个字典</p>

<p>30.MentholPackMethod StackState CallFunction(StackState fu);</p>
<p>执行函数</p>

<ol start="31">
<li>MentholPackMethod void SetPrintCompileErrorFunc(PrintErrorFunc _pef);</li>
</ol>
<p>编译时错误提示函数</p>

<p>32.MentholPackMethod void SetPrintRunTimeErrorFunc(PrintErrorFunc _pef);</p>
<p>运行时错误提示函数</p>

<p>33.typedef int (*PrintErrorFunc)(char* str,char* cf,int line);</p>
<p>错误提示函数</p>

<h1>第四章 开发扩展程序</h1>
<h2   id="4.1">4.1.如何写一个扩展库</h2>

<p>如果要开发自定义的扩展类库，目前menthol的扩展开发仅可使用C/C++进行开发，你需要了解的几个开发前提是：</p>
<p>1.所有被扩展的函数必须要是静态的函数或者是全局的函数</p>
<p>2.所有被扩展的函数都必须要返回StackState</p>
<p>3.所有的扩展函数库必须有个函数MentholPackMethod void MP_Init()，这个函数内会调用RegisterPackAgeFunciton将你的函数增加至运行环境内</p>
<p>4.会写或者会改C/C++源码，并且能生成DLL库</p>

<p>menthol扩展开发非常简单，你需要在你的C/C++页面内引入menthol.lib静态库，并且将头文件menthol.h加入到你的源代码中。我下面将以VS中开发为范例开发一个最简单的扩展库</p>

<p>1.在VS中创建了一个类库</p>

 <p><img src="/static/mentholhtmlimg/mentholhtml24871.png"/></p>
   <p><img src="/static/mentholhtmlimg/mentholhtml24882.png"/></p>

<ol start="2">
<li>引入h或者引入menthol所在目录也可以，然后把lib文件包含在内，然后创建启动函数，启动函数的名为</li>
</ol>
<p>MP_Init,大小写要注意</p>
 <img src="/static/mentholhtmlimg/mentholhtml24962.png"/>

<ol start="3">
<li>我们写一个函数，这个函数的功能是，我们输入任何字符串，他都会输出&rdquo;hello&rdquo;+ 刚才你输入的字符串</li>
</ol>

 <img src="/static/mentholhtmlimg/mentholhtml25015.png"/>
<p>然后在代码中调用</p>

 <img src="/static/mentholhtmlimg/mentholhtml25028.png"/>

<p>好了，现在到程序中测试一下，</p>

 <img src="/static/mentholhtmlimg/mentholhtml25046.png"/>
</div>
</body>
</html>


